/*
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@:            @@     .@@@@           @@+     @@      @@             @@
@@@@@@            @@#     @@@             @@      @@      @@             @@
@@@@@@            @@      @@.             @@      @@      @@             @@
@@@@@@            @@      @@             -@@     %@@     @@-            @@@
@@@@@            .@@     #@@             @@      @@      @@             @@@
@@@@@@@@@@@@@@@@@@@.     @@      @@@@@@@@@@      @@      @@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@      @@      @@@@@@@@@@      @@     +@@@@@@@@@@@@@@@@@@
@@@@%          @@@@      @@     :       %@@             @@@@@@      @@@@@@@
@@@@           @@@@     @@*     @       @@              @@@@@@     @@@@@@@@
@@@@           @@@      @@      @       @@              @@@@@      @@@@@@@@
@@@@          *@@@      @@              @@             @@@@@@      @@@@@@@@
@@@.          @@@@     :@@     %       @@+             @@@@@@      @@@@@@@@
@@@      @@@@@@@@*     @@.     @@      @@      @@      @@@@@@     @@@@@@@@@
@@@      @@@@@@@@      @@      @@      @@      @@     .@@@@@      @@@@@@@@@
@@@     @@@@@@@@@      @@      @      =@@     %@@     @@@@@@      @@@@@@@@@
@@      @@@@@@@@@     %@@             @@      @@      @@@@@@     -@@@@@@@@@
@@      @@@@@@@@.     @@#             @@      @@      @@@@@=     @@@@@@@@@@
@@     :@@@@@@@@      @@@            @@@      @@     +@@@@@      @@@@@@@@@@
@#     @@@@@@@@@      @@@:          @@@@     @@:     @@@@@@      @@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@      @@@      @@@      @@@      @@#             @@@@@@
@@@@@@@@@@@@@@@@@@@@      @@#      @@:      @@       @@              .@@@@@
@@@@@@@@@@@@@@@@@@@       @@       @@       @@      .@@               @@@@@
@@@@@@@@@@@@@@@@@@@      :@@      *@@      @@@      @@@               @@@@@
@@@@@@@@@@@@@@@@@@@      @@@      @@@      @@#      @@-               @@@@@
@@@@@@@@@@@@@@@@@@*      @@:      @@       @@       @@@@@@@@@@@      .@@@@@
@@@@@@@@@@@@@@@@@@       @@       @@      .@@      +@@@@@@@@@@@      @@@@@@
@@@@@@@@@@@@@@@@@@      #@@      @@@      @@@      @@@@@@@@@@@       @@@@@@
@@@@@@@@@@@@@@@@@@               @@#      @@:      @@                @@@@@@
@@@@@@@@@@@@@@@@@:               @@       @@       @@               @@@@@@@
@@@@@@@@@@@@@@@@@               .@@      #@@      @@@              @@@@@@@@
@@@@@@@@@@@@@@@@@               @@@      @@@      @@%               @@@@@@@
@@@@@@@@@@@@@@@@@               @@:      @@       @@                @@@@@@@
@@@@@@@@@@@@@@@@                @@       @@      .@@      =@=      @@@@@@@@
@@@@@@@@@@@@@@@@      .@@      *@@      @@@      @@@      @@@      @@@@@@@@
@@@@@@@@@@@@@@@@      @@@      @@@      @@*      @@-      @@       @@@@@@@@
@@@@@@@@@@@@@@@#      @@:      @@        -       @@       #        @@@@@@@@
@@@@@@@@@@@@@@@       @@       @@               *@@               @@@@@@@@@
@@@@@@@@@@@@@@@      *@@      @@@               @@@               @@@@@@@@@
@@@@@@@@@@@@@@@      @@@      @@@              @@@               @@@@@@@@@@
@@@@@@@@@@@@@@:      @@       @@@@            @@@@              @@@@@@@@@@@
@@@@@@@@@@@@@@       @@      .@@@@@         .@@@@@            =@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
/*

/*
WEBSITE   - https://FightHub.xyz
TWITTER/X - https://twitter.com/FightHubXyz
TELEGRAM  - https://t.me/FightHubXyz
*/

// SPDX-License-Identifier: None
pragma solidity ^0.8.21;

import "./ReentrancyGuard.sol";
import "./IERC20.sol";
import "./SafeERC20.sol";

contract TYSONVSFRANCISRISKTOEARN is ReentrancyGuard {
	using SafeERC20 for IERC20;

    address public owner;
    IERC20 public FIGHTHUB;
    uint256 public requiredTokenAmount;
    bool public bettingOpen = true;
    bool public fightEnded;
    bool public paused = false;
    bytes32 public fightWinner;
    uint256 public contractDeploymentTime;

    bytes32 public constant TYSON_FURY = keccak256("TysonFury");
    bytes32 public constant FRANCIS_NGANNOU = keccak256("FrancisNgannou");
    bytes32 public constant DRAW = keccak256("Draw");


    struct Bet {
        uint256 amount;
        bytes32 fighter;
        bool claimed;
    }

    mapping(address => Bet) public bets;
    mapping(address => uint256) public tysonBets;
    mapping(address => uint256) public francisBets;
    mapping(address => uint256) public tokenBalances;

    uint256 public totalTysonBets;
    uint256 public totalFrancisBets;

    event BetPlaced(address indexed bettor, bytes32 fighter, uint256 amount);
    event FightEnded(bytes32 winner);
    event PrizeClaimed(address indexed bettor, uint256 amount);
    event RefundClaimed(address indexed bettor, uint256 amount);
    event ContractPaused();
    event ContractResumed();
    event BettingStopped();
    event TokensBurned(uint256 amount);
    event TokenDeposited(address indexed user, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call this function.");
        _;
    }

    modifier afterFight() {
        require(fightEnded, "Fight has not ended yet.");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, "Contract is paused.");
        _;
    }

    modifier whenPaused() {
        require(paused, "Contract is not paused.");
        _;
    }

    constructor(address _FIGHTHUBAddress, uint256 _initialRequiredTokenAmount) {
        require(_FIGHTHUBAddress != address(0), "Token address cannot be zero.");
        owner = msg.sender;
        FIGHTHUB = IERC20(_FIGHTHUBAddress);
        contractDeploymentTime = block.timestamp;
        requiredTokenAmount = _initialRequiredTokenAmount;
    }

    function setRequiredTokenAmount(uint256 _newRequiredAmount) external onlyOwner {
        requiredTokenAmount = _newRequiredAmount; 
    }

    function burnTokens(uint256 _amount) external onlyOwner {
        
        // Ensure that the user is burning tokens
        require(_amount > 0, "Invalid burn amount");

        // Ensure that the contract has enough tokens to burn
        require(FIGHTHUB.balanceOf(address(this)) >= _amount, "Not enough tokens to burn");

        // Call the burn function of the ERC-20 token contract
        FIGHTHUB.burn(_amount);

        // Emit an event to log the token burning
        emit TokensBurned(_amount);
    }

    receive() external payable {
        revert("USE THE PLACE BET FUNCTION, WE DON'T ACCEPT RANDOM ETH SENDS");
    }

    function sendRequiredTokens() external whenNotPaused {
        require(bettingOpen, "Betting is closed.");
        require(tokenBalances[msg.sender] < requiredTokenAmount, "You've already sent the required amount.");

        // Ensure that the contract has the required allowance to transfer tokens
        require(FIGHTHUB.allowance(msg.sender, address(this)) >= requiredTokenAmount, "The $FIGHT contract does not have the correct token allowance");

        // Transfer the required tokens from the sender's wallet to the contract
        FIGHTHUB.safeTransferFrom(msg.sender, address(this), requiredTokenAmount);
        
        // Update the user's token balance
        tokenBalances[msg.sender] += requiredTokenAmount;

        // Emit an event to log the token deposit
        emit TokenDeposited(msg.sender, requiredTokenAmount);
    }

    function togglePause() external onlyOwner {
        paused = !paused;
        if (paused) {
            emit ContractPaused();
        } else {
            emit ContractResumed();
        }
    }

    function getTotalBetsForFighter(bytes32 _fighter) public view returns (uint256) {
        if (_fighter == TYSON_FURY) {
            return totalTysonBets;
        } else if (_fighter == FRANCIS_NGANNOU) {
            return totalFrancisBets;
        }
        return 0;
    }

    function getUserBet(address _user) public view returns (uint256, bytes32) {
        return (bets[_user].amount, bets[_user].fighter);
    }

    function safeTransfer(address payable recipient, uint256 amount) internal {
        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Transfer failed.");
    }

    function placeBet(bytes32 _fighter) external payable whenNotPaused {
        require(msg.value > 0, "You must send some Ether to place a bet.");
        require(bets[msg.sender].amount == 0, "You have already placed a bet with this wallet.");
        require(bettingOpen, "Betting is closed.");
        require(_fighter == TYSON_FURY || _fighter == FRANCIS_NGANNOU, "Invalid fighter selected.");
        require(tokenBalances[msg.sender] >= requiredTokenAmount, "Insufficient tokens deposited.");

        uint256 feeAmount = msg.value * 10 / 100; // assuming 10% fee
        uint256 betAmount = msg.value - feeAmount;

        // Transfer fee to the owner
        safeTransfer(payable(owner), feeAmount);

        bets[msg.sender] = Bet({
            amount: betAmount,
            fighter: _fighter,
            claimed: false
        });

        if (_fighter == TYSON_FURY) {
            tysonBets[msg.sender] += betAmount;
            totalTysonBets += betAmount;
        } else if (_fighter == FRANCIS_NGANNOU) {
            francisBets[msg.sender] += betAmount;
            totalFrancisBets += betAmount;
        }

        emit BetPlaced(msg.sender, _fighter, betAmount);
    }

    function stopBets() external onlyOwner {
        bettingOpen = false;
        emit BettingStopped();
    }

    function endFight(bytes32 _winner) external onlyOwner {
        require(!fightEnded, "Fight has already ended.");
        require(_winner == TYSON_FURY || _winner == FRANCIS_NGANNOU || _winner == DRAW, "Invalid fighter selected.");

        fightEnded = true;
        fightWinner = _winner;

        emit FightEnded(_winner);
    }

    function claimPrize() external afterFight nonReentrant {
        require(bets[msg.sender].amount > 0, "You didn't place a bet.");
        require(bets[msg.sender].fighter == fightWinner, "You bet on the wrong fighter.");
        require(!bets[msg.sender].claimed, "You have already claimed your rewards.");

        uint256 userWinnerShare = 0;
    	uint256 userLoserShare = 0;
    	
    	// Calculate the user's share of the winner pool (original bet)
    	userWinnerShare = bets[msg.sender].amount;

    	// Calculate the user's share of the loser pool based on their bets on the winning fighter
        if (fightWinner == TYSON_FURY) {
        	userLoserShare = (bets[msg.sender].amount * totalFrancisBets) / totalTysonBets;
        } else if (fightWinner == FRANCIS_NGANNOU) {
       	 	userLoserShare = (bets[msg.sender].amount * totalTysonBets) / totalFrancisBets;
        }

        // Calculate the total prize (original bet + share of loser's pool)
        uint256 totalPrize = userWinnerShare + userLoserShare;

        bets[msg.sender].claimed = true;

        // Transfer the total prize to the user
        safeTransfer(payable(msg.sender), totalPrize);

        emit PrizeClaimed(msg.sender, totalPrize);
    }
    
    function claimRefund() external afterFight nonReentrant {
    	require(bets[msg.sender].amount > 0, "You didn't place a bet.");
    	require(!bets[msg.sender].claimed, "You have already claimed your refund.");
    	require(fightWinner == DRAW, "Refunds are only available in case of a draw.");

    	uint256 userBetAmount = bets[msg.sender].amount;
    	uint256 userTokenBalance = tokenBalances[msg.sender];

    	bets[msg.sender].claimed = true;

    	// Transfer the refund to the user (the original bet amount)
    	safeTransfer(payable(msg.sender), userBetAmount);
    	
    	// Transfer the refund of $FIGHT tokens to the user
    	FIGHTHUB.safeTransfer(msg.sender, userTokenBalance);

    	emit RefundClaimed(msg.sender, userBetAmount);
	}

    function withdrawUnclaimedFunds() external onlyOwner {
        require(block.timestamp >= contractDeploymentTime + 30 days, "You can only withdraw after 1 month from deployment.");
        uint256 remainingBalance = address(this).balance;
        require(remainingBalance > 0, "No funds to withdraw.");

        safeTransfer(payable(owner), remainingBalance);
    }
}